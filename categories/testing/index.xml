<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Testing on Manabie Tech Blog</title><link>/categories/testing/</link><description>Recent content in Testing on Manabie Tech Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Except where otherwise noted, content on this site is licensed under a [Creative Commons Attribution 4.0 International license](https://creativecommons.org/licenses/by-sa/4.0/).</copyright><atom:link href="/categories/testing/index.xml" rel="self" type="application/rss+xml"/><item><title>Snapshot test your Postgresql in Golang pgx driver</title><link>/1/01/snapshot-test-your-postgresql-in-golang-pgx-driver/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/1/01/snapshot-test-your-postgresql-in-golang-pgx-driver/</guid><description>How about using a containerized DB? In some applications, the repository layer don&amp;rsquo;t have much logic (maybe concat some WHERE conditions), only propagate the SQL statement to DB - where the real complexity happen with all the fake data and logic.
Testing with a simple containerized DB is a good option where you can:
verify the syntax, and checking the logic Good option? Yes but not the best option for all the cases.</description></item></channel></rss>